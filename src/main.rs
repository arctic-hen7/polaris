mod cli;
mod extractors;
mod parse;
mod views;

use crate::cli::{Cli, Encoding};
use crate::extractors::*;
use crate::parse::*;
use crate::views::TasksFilter;
use anyhow::{Error, Result};
use chrono::Local;
use clap::Parser;
use serde::Serialize;
use std::collections::HashMap;
use std::io::Write;

fn main() -> Result<()> {
    let mut args = Cli::parse();
    let mut views = match args.parse_views()? {
        Some(views) => views,
        // This means the user asked for the help message about views, and we should terminate
        // (it's already been printed)
        None => return Ok(()),
    };

    let expand_until =
        views.last_date.unwrap_or_else(|| Local::now().date_naive()) + *args.repeat_buffer;

    // Fetch the raw action items from Starling and normalise them, expanding repeating timestamps
    let raw_nodes = get_raw_action_items(
        NodeOptions {
            body: true,
            metadata: true,
            children: true,
            connections: false,
            child_connections: false,
            conn_format: Format::Markdown,
        },
        &args.starling_address,
    )?;
    let action_items = normalize_action_items(raw_nodes, &args.done_keywords, expand_until)?;

    macro_rules! handle_items {
        ($ItemType:ty, $Variant:expr, $views:expr) => {
            action_items
                .values()
                // Parse and convert into the right kind of action item
                .flat_map(|item| <$ItemType>::from_action_item(item, &action_items))
                .try_fold(HashMap::new(), |mut map, item_res| {
                    let item = item_res?; // Fail fast
                    for (name, filter) in $views {
                        // If the item matches the filter, add it to the map under the view's name
                        if filter.matches(&item) {
                            map.entry(name.to_string())
                                .or_insert_with(Vec::new)
                                .push(item.clone());
                        }
                    }

                    Ok::<_, Error>(map)
                })?
                .into_iter()
                .map(|(view_name, mut items)| {
                    // Sort by the key
                    items.sort_unstable_by_key(<$ItemType>::sort_key);
                    (view_name, $Variant(items))
                })
        };
    }

    let mut views_data = HashMap::new();

    // For each type of item, go through the action items and parse them (thereby validating),
    // and then map each item against the relevant filter type, creating an iterator of pairs
    // `(view_name, item)` for every view/event pair that matches the involved view's filter.
    // We can safely put everything into the same map because no view can use multiple types, so
    // the keys generated by handling each type are disjoint.
    views_data.extend(handle_items!(Event, ViewData::Events, &views.events));
    views_data.extend(handle_items!(
        DailyNote,
        ViewData::DailyNotes,
        &views.daily_notes
    ));
    views_data.extend(handle_items!(Tickle, ViewData::Tickles, &views.tickles));
    views_data.extend(handle_items!(
        PersonDate,
        ViewData::PersonDates,
        &views.dates
    ));
    views_data.extend(handle_items!(Project, ViewData::Projects, &views.projects));
    views_data.extend(handle_items!(Waiting, ViewData::Waitings, &views.waits));
    // We inject extra filters for all the target context views so we can easily iterate over the
    // tasks relevant to them
    let mut target_context_view_names = Vec::with_capacity(views.target_contexts.len());
    for (name, filter) in &views.target_contexts {
        let interim_task_filter_name = format!("__interim_target_contexts__{name}");
        target_context_view_names.push(interim_task_filter_name.clone());
        views.tasks.push((
            interim_task_filter_name,
            TasksFilter::for_target_contexts(filter),
        ));
    }
    views_data.extend(handle_items!(Task, ViewData::Tasks, &views.tasks));

    // Now go through the target contexts and accumulate
    for name in target_context_view_names {
        // For each target contexts view, we inserted an extra view for the tasks that extracts
        // only those tasks with deadlines on or before the `until` date, so get those now. This is
        // guaranteed to exist, and of course to be a tasks filter.
        let relevant_tasks = match views_data.remove(&name).unwrap() {
            ViewData::Tasks(tasks) => tasks,
            _ => unreachable!(),
        };

        // Accumulate a map of contexts, and under each one have the tasks that need to be done in
        // that context by the deadline date. Because these were sorted in the original task
        // filtering system and we iterate in that order, they'll be in the correct order in each
        // context bucket.
        let mut target_contexts = HashMap::new();
        for task in relevant_tasks {
            for context in &task.contexts {
                target_contexts
                    .entry(context.clone())
                    .or_insert_with(Vec::new)
                    .push(task.clone());
            }
            // If a task has no contexts, that's a special area
            if task.contexts.is_empty() {
                target_contexts
                    .entry(String::new())
                    .or_insert_with(Vec::new)
                    .push(task.clone());
            }
        }

        views_data.insert(name, ViewData::TargetContexts(target_contexts));
    }

    match args.encoding {
        Encoding::Bincode => {
            let bytes = bincode::serialize(&views_data)?;
            std::io::stdout().write_all(&bytes)?;
            std::io::stdout().flush()?;
        }
        Encoding::Json => {
            println!("{}", serde_json::to_string(&views_data)?);
        }
    };

    Ok(())
}

/// The final data for a single view (which will be over a single data type).
#[derive(Serialize)]
#[serde(rename_all = "snake_case")]
enum ViewData {
    Events(Vec<Event>),
    DailyNotes(Vec<DailyNote>),
    Tickles(Vec<Tickle>),
    PersonDates(Vec<PersonDate>),
    Tasks(Vec<Task>),
    Projects(Vec<Project>),
    Waitings(Vec<Waiting>),
    // Map of context that needs to be entered before the filter's `until` date to the tasks that
    // need to be done in that context
    TargetContexts(HashMap<String, Vec<Task>>),
}
