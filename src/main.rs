mod cli;
mod extractors;
mod parse;
mod views;

use crate::cli::{Cli, Encoding};
use crate::extractors::*;
use crate::parse::*;
use crate::views::TasksFilter;
use anyhow::{bail, Error, Result};
use chrono::Local;
use clap::Parser;
use serde::Serialize;
use std::collections::HashMap;
use std::io::Write;

fn main() -> Result<()> {
    let mut args = Cli::parse();
    let mut views = match args.parse_views()? {
        Some(views) => views,
        // This means the user asked for the help message about views, and we should terminate
        // (it's already been printed)
        None => return Ok(()),
    };

    let expand_until =
        views.last_date.unwrap_or_else(|| Local::now().date_naive()) + *args.repeat_buffer;

    // Fetch the raw action items from Starling and normalise them, expanding repeating timestamps
    let raw_nodes = get_raw_action_items(
        NodeOptions {
            body: true,
            metadata: true,
            children: true,
            connections: false,
            child_connections: false,
            conn_format: Format::Markdown,
        },
        &args.starling_address,
    )?;
    let action_items = normalize_action_items(raw_nodes, &args.done_keywords, expand_until)?;

    macro_rules! handle_items {
        ($ItemType:ty, $variant:ident, $views:expr, $views_data:expr) => {{
            action_items
                .values()
                // Parse and convert into the right kind of action item
                .flat_map(|item| <$ItemType>::from_action_item(item, &action_items))
                .try_fold(HashMap::new(), |mut map, item_res| {
                    let item = item_res?; // Fail fast
                    for (name, filter) in $views {
                        // Get the entry first to make sure we add all the type-specific entries
                        // this view needs (otherwise the data format is uncertain)
                        let entry = map.entry(name.to_string()).or_insert_with(Vec::new);
                        // If the item matches the filter, add it to the map under the view's name
                        if filter.matches(&item) {
                            entry.push(item.clone());
                        }
                    }

                    Ok::<_, Error>(map)
                })?
                .into_iter()
                .try_for_each(|(view_name, mut items)| {
                    // Sort items by the key
                    items.sort_unstable_by_key(<$ItemType>::sort_key);

                    // Get the entry for this view (inserting if needed), and add the data for this
                    // type of item in (if already present, fail)
                    let view_data = $views_data
                        .entry(view_name.clone())
                        .or_insert_with(ViewData::default);
                    if view_data.$variant.is_some() {
                        bail!("view `{}` has two filters the same type", view_name);
                    }
                    view_data.$variant = Some(items);

                    Ok(())
                })?;
        }};
    }

    let mut views_data = HashMap::new();
    for name in views.names() {
        views_data.insert(name.to_string(), ViewData::default());
    }

    // For each type of item, go through the action items and parse them (thereby validating),
    // and then map each item against the relevant filter type, creating an iterator of pairs
    // `(view_name, item)` for every view/event pair that matches the involved view's filter.
    // We can safely put everything into the same map because no view can use multiple types, so
    // the keys generated by handling each type are disjoint.
    handle_items!(Event, events, &views.events, views_data);
    handle_items!(DailyNote, daily_notes, &views.daily_notes, views_data);
    handle_items!(Tickle, tickles, &views.tickles, views_data);
    handle_items!(PersonDate, person_dates, &views.dates, views_data);
    handle_items!(Project, projects, &views.projects, views_data);
    handle_items!(Waiting, waitings, &views.waits, views_data);
    handle_items!(PersonDate, person_dates, &views.dates, views_data);
    // We inject extra filters for all the target context views so we can easily iterate over the
    // tasks relevant to them
    let mut target_context_view_names = Vec::with_capacity(views.target_contexts.len());
    for (name, filter) in &views.target_contexts {
        let interim_task_filter_name = format!("__interim_target_contexts__{name}");
        target_context_view_names.push(interim_task_filter_name.clone());
        views.tasks.push((
            interim_task_filter_name,
            TasksFilter::for_target_contexts(filter),
        ));
    }
    handle_items!(Task, tasks, &views.tasks, views_data);

    // Now go through the target contexts and accumulate
    for (interim_name, (name, filter)) in target_context_view_names
        .iter()
        .zip(views.target_contexts.iter())
    {
        // For each target contexts view, we inserted an extra view for the tasks that extracts
        // only those tasks with deadlines on or before the `until` date, so get those now. This is
        // guaranteed to exist, and of course to contain tasks.
        let relevant_tasks = views_data
            .remove(interim_name)
            .unwrap()
            .tasks
            .take()
            .unwrap();

        // Accumulate a map of contexts, and under each one have the tasks that need to be done in
        // that context by the deadline date. Because these were sorted in the original task
        // filtering system and we iterate in that order, they'll be in the correct order in each
        // context bucket.
        let mut target_contexts = HashMap::new();
        for task in relevant_tasks {
            if filter.first_context_only && !task.contexts.is_empty() {
                // Get the alphabetically first context (until `orgish` supports tag ordering...)
                let first_context = task
                    .contexts
                    .iter()
                    .min()
                    // Guaranteed to be non-empty by the above check
                    .unwrap();
                target_contexts
                    .entry(first_context.clone())
                    .or_insert_with(Vec::new)
                    .push(task.clone());
            } else {
                for context in &task.contexts {
                    target_contexts
                        .entry(context.clone())
                        .or_insert_with(Vec::new)
                        .push(task.clone());
                }
            }
            // If a task has no contexts, that's a special area
            if task.contexts.is_empty() {
                target_contexts
                    .entry(String::new())
                    .or_insert_with(Vec::new)
                    .push(task.clone());
            }
        }

        let entry = views_data
            .entry(name.to_string())
            .or_insert_with(ViewData::default);
        if entry.target_contexts.is_some() {
            bail!("view `{}` has two filters the same type", name);
        }
        entry.target_contexts = Some(target_contexts);
    }

    // If the user requested goal views, run that extraction (unrelated to action items, and we
    // shouldn't do any checking unless they request because it's a very personally-tuned system
    // that most people will need to fork to get working)
    #[cfg(feature = "goals")]
    for (view_name, filter) in views.goals {
        let goals = Goals::extract(filter.date, &args.starling_address)?;

        let entry = views_data
            .entry(view_name.clone())
            .or_insert_with(ViewData::default);
        if entry.goals.is_some() {
            bail!("view `{}` has two filters the same type", view_name);
        }
        entry.goals = Some(goals);
    }

    match args.encoding {
        Encoding::Bincode => {
            let bytes = bincode::serialize(&views_data)?;
            std::io::stdout().write_all(&bytes)?;
            std::io::stdout().flush()?;
        }
        Encoding::Json => {
            println!("{}", serde_json::to_string(&views_data)?);
        }
    };

    Ok(())
}

/// The final data for a single view, which may contain multiple data types.
#[derive(Serialize, Default)]
struct ViewData {
    #[serde(skip_serializing_if = "Option::is_none")]
    events: Option<Vec<Event>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    daily_notes: Option<Vec<DailyNote>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    tickles: Option<Vec<Tickle>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    person_dates: Option<Vec<PersonDate>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    tasks: Option<Vec<Task>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    projects: Option<Vec<Project>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    waitings: Option<Vec<Waiting>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    target_contexts: Option<HashMap<String, Vec<Task>>>,
    #[cfg(feature = "goals")]
    #[serde(skip_serializing_if = "Option::is_none")]
    goals: Option<Goals>,
}
